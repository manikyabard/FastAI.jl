<HTML><head><title>fastai API comparison</title><script src=../template/highlight.min.js ></script><script src=../template/julia.min.js ></script><script src=../template/loadhighlightjs.js ></script><link href=../template/ansi.css rel=stylesheet ></link><link href=../template/hugobook.css rel=stylesheet ></link><meta content=Type=text/html; charset=utf-8 http-equiv=Content-Type ></meta><meta name=viewport content=width=device-width, initial-scale=1 ></meta></head><body><input onclick=toggleMenu() id=menu-control class=hidden toggle type=checkbox ></input><input id=toc-control type=checkbox class=hidden toggle ></input><main class=container flex ><aside id=menu-container class=book-menu ><nav class=book-menu-content ><h2 id=title >FastAI.jl</h2><div id=sidebar ><div class=doctree ><body><ul><li><p><a href=../README.md.html title= >README</a></p></li><li><p><a href=setup.md.html title= >Setup</a></p></li><li><p>Tutorials</p><ul><li><p><a href=introduction.md.html title= >Introduction</a></p></li><li><p><a href=../notebooks/quickstart.ipynb.html title= >Quickstart</a></p></li><li><p>Vision</p><ul><li><p><a href=../notebooks/imagesegmentation.ipynb.html title= >Image segmentation</a></p></li><li><p><a href=../notebooks/keypointregression.ipynb.html title= >Keypoint regression</a></p></li></ul></li><li><p>Intermediate</p><ul><li><p><a href=data_containers.md.html title= >Data containers</a></p></li><li><p><a href=../notebooks/serialization.ipynb.html title= >Saving and loading models</a></p></li></ul></li><li><p>Advanced</p><ul><li><p><a href=../notebooks/presizing.ipynb.html title= >Presizing vision datasets</a></p></li><li><p><a href=learning_methods.md.html title= >Custom Learning methods</a></p></li></ul></li></ul></li><li><p>How To</p><ul><li><p><a href=../notebooks/fitonecycle.ipynb.html title= >Train a model from scratch</a></p></li><li><p><a href=../notebooks/finetune.ipynb.html title= >Finetune a pretrained model</a></p></li><li><p><a href=../notebooks/lrfind.ipynb.html title= >Find a good learning rate</a></p></li><li><p><a href=howto/augmentvision.md.html title= >Augment vision data</a></p></li><li><p><a href=../notebooks/how_to_visualize.ipynb.html title= >Visualize data</a></p></li><li><p><a href=howto/logtensorboard.md.html title= >Log to TensorBoard</a></p></li></ul></li><li><p>Reference</p><ul><li><p><a href=../REFERENCE.html title= >Docstrings</a></p></li><li><p><a href=fastai_api_comparison.md.html title= >fastai API comparison</a></p></li><li><p><a href=api.md.html title= >API</a></p></li><li><p><a href=interfaces.md.html title= >Extension APIs</a></p></li><li><p><a href=glossary.md.html title= >Glossary</a></p></li></ul></li><li><p>Background</p><ul><li><p><a href=background/datapipelines.md.html title= >Performant data pipelines</a></p></li></ul></li></ul></body></div></div></nav></aside><div class=book-page ><header class=book-header ></header><article><h1 id=fastai-api-comparison >fastai API comparison</h1><p>FastAI.jl is in many ways similar to the original Python <a href=./docs.fast.fast.ai.html title= >fastai</a>, but also has its differences. This reference goes through all the sections in the <a href=https://arxiv.org/abs/2002.04688 title= >fastai: A Layered API for Deep Learning</a> paper and comments what the interfaces for the same functionality in FastAI.jl are, and where they differ or functionality is still missing.</p><h2 id=applications >Applications</h2><p>FastAI.jl’s own data block API makes it possible to derive every part of a high-level interface and as such there is no need for application-specific functions like fastai’s <code>ImageDataLoaders</code>, <code>SegmentationDataLoaders</code>, <code>cnn_learner</code> or <code>unet_learner</code>. Instead it suffices to create a learning method and based on the blocks and encodings specified, the proper model builder, loss function, and visualizations are implemented. For a high-level API, a complete <code>Learner</code> can be constructed using <a href=../REFERENCE/FastAI.methodlearner.html ><code>methodlearner</code></a> without much boilerplate. The application-specific logic hence lies only in the application-specific data blocks and encodings.</p><h3 id=vision >Vision</h3><p>Computer vision is the most developed part of FastAI.jl with good support for different tasks and optimized data pipelines with N-dimensional images, masks and keypoints. See the tutorial section for many examples.</p><h3 id=tabular >Tabular</h3><p>Support for tabular data is currently in the works as part of an ongoing Google Summer of Code project. The progress is tracked in <a href=https://github.com/FluxML/ML-Coordination-Tracker/issues/34 title= >this issue</a>.</p><h3 id=deployment >Deployment</h3><p>Through FastAI.jl’s <a href=./learning_methods.md.html title= ><code>LearningMethod</code> interface</a>, the data processing logic is decoupled from the dataset creation and training and can be easily serialized and loaded to make predictions. See the tutorial on <a href=../notebooks/serialization.ipynb.html title= >saving and loading models</a>.</p><hr></hr><p>There is no integration (yet!) for text and collaborative filtering applications.</p><h2 id=high-level-api >High-level API</h2><h3 id=high-level-api-foundations >High-level API foundations</h3><p>FastAI.jl also has a data block API but it differs from fastai’s in a number of ways. In the Julia package it only handles the data encoding and decoding part, and doesn’t concern itself with creating datasets. For dataset loading, see the <a href=./data_containers.md.html title= >data container API</a>. As mentioned above, the high-level application-specific logic is also derived from the data block API. To use it you need to specify a tuple of input and target blocks as well as a tuple of encodings that are applied to the data. The encodings  are invertible data-specific data processing steps which correspond to <code>fastai.Transform</code>s. As in fastai, dispatch is used to transform applicable data and pass other data through unchanged. Unlike in fastai, there are no default steps associated with a block, allowing greater flexibility.</p><p>We can create a <code>BlockMethod</code> (corresponding to <code>fastai.DataBlock</code>) and get information about the representations the data goes through.</p><div class=cellcontainer cell=main lang=julia ><pre class=codecell cell=main lang=julia ><code>using FastAI

method = BlockMethod(
    (Image{2}(), Mask{2}([&quot;foreground&quot;, &quot;background&quot;])),
    (
        ProjectiveTransforms((128, 128)),
        ImagePreprocessing(),
        OneHot(),
    )
)
describemethod(method)
</code></pre><div class=coderesult ><div class="markdown"><h4><code>LearningMethod</code> summary</h4>
<ul>
<li><p>Task: <code>FastAI.Image&#123;2&#125; -&gt; Mask&#123;2, String&#125;</code></p>
</li>
<li><p>Model blocks: <code>FastAI.ImageTensor&#123;2&#125; -&gt; FastAI.OneHotTensor&#123;2, String&#125;</code></p>
</li>
</ul>
<p>Encoding a sample &#40;<code>encode&#40;method, context, sample&#41;</code>&#41;</p>
<table><tr><th align="right">Encoding</th><th align="right">Name</th><th align="right"><code>method.blocks&#91;1&#93;</code></th><th align="right"><code>method.blocks&#91;2&#93;</code></th></tr><tr><td align="right"></td><td align="right"><code>&#40;input, target&#41;</code></td><td align="right"><code>FastAI.Image&#123;2&#125;</code></td><td align="right"><code>Mask&#123;2, String&#125;</code></td></tr><tr><td align="right"><code>ProjectiveTransforms</code></td><td align="right"></td><td align="right"><strong><code>FastAI.Image&#123;2&#125;</code></strong></td><td align="right"><strong><code>Mask&#123;2, String&#125;</code></strong></td></tr><tr><td align="right"><code>ImagePreprocessing</code></td><td align="right"></td><td align="right"><strong><code>FastAI.ImageTensor&#123;2&#125;</code></strong></td><td align="right"><code>Mask&#123;2, String&#125;</code></td></tr><tr><td align="right"><code>OneHot</code></td><td align="right"><code>&#40;x, y&#41;</code></td><td align="right"><code>FastAI.ImageTensor&#123;2&#125;</code></td><td align="right"><strong><code>FastAI.OneHotTensor&#123;2, String&#125;</code></strong></td></tr></table>
<p>Decoding a model output &#40;<code>decode&#40;method, context, ŷ&#41;</code>&#41;</p>
<table><tr><th align="right">Decoding</th><th align="right">Name</th><th align="right"><code>method.outputblock</code></th></tr><tr><td align="right"></td><td align="right"><code>ŷ</code></td><td align="right"><code>FastAI.OneHotTensor&#123;2, String&#125;</code></td></tr><tr><td align="right"><code>OneHot</code></td><td align="right"></td><td align="right"><strong><code>Mask&#123;2, String&#125;</code></strong></td></tr><tr><td align="right"><code>ImagePreprocessing</code></td><td align="right"></td><td align="right"><code>Mask&#123;2, String&#125;</code></td></tr><tr><td align="right"><code>ProjectiveTransforms</code></td><td align="right"><code>target_pred</code></td><td align="right"><code>Mask&#123;2, String&#125;</code></td></tr></table>
</div></div></div><p>From this short definition, many things can be derived:</p><ul><li><p>data encoding</p></li><li><p>model output decoding</p></li><li><p>how to create a model from a backbone</p></li><li><p>the loss function to use</p></li><li><p>how to visualize samples and predictions</p></li></ul><p>Together with a <a href=./data_container.html title= >data container</a> <code>data</code>, we can quickly create a <code>Learner</code> using <a href=../REFERENCE/FastAI.methodlearner.html ><code>methodlearner</code></a> which, like in fastai, handles the training for us. There are no application-specific <code>Learner</code> constructors like <code>cnn_learner</code> or <code>unet_learner</code> in FastAI.jl.</p><pre lang=julia ><code>learner = methodlearner(method, data)
</code></pre><p>High-level training protocols like the <a href=../notebooks/fitonecycle.ipynb.html title= >one-cycle learning rate schedule</a>, <a href=../notebooks/finetune.ipynb.html title= >fine-tuning</a> and the <a href=../notebooks/lrfind.ipynb.html title= >learning rate finder</a> are then available to us:</p><pre lang=julia ><code>fit!(learner, 10)                  # Basic training for 10 epochs
finetune!(learner, 5, 1e-3)        # Finetuning regimen for 1+5 epochs with lr=1e-3
fitonecycle!(learner, 10)          # One-cycle learning rate regimen
res = lrfind(learner); plot(res)   # Run learning rate finder and plot suggestions
</code></pre><h3 id=incrementally-adapting-pytorch-code >Incrementally adapting PyTorch code</h3><p>Since it is a Julia package, FastAI.jl is not written on top of PyTorch, but a Julia library for deep learning: <a href=http://www.fluxml.ai title= >Flux.jl</a>. In any case, the point of this section is to note that the abstractions in fastai are decoupled and existing projects can easily be reused. This is also the case for FastAI.jl as it is built on top of several decoupled libraries. Many of these were built specifically for FastAI.jl, but they are unaware of each other and useful in their own right:</p><ul><li><p><a href=https://github.com/FluxML/Flux.jl title= >Flux.jl</a> provides models, optimizers, and loss functions, fulfilling a similar role to PyTorch</p></li><li><p><a href=https://github.com/JuliaML/MLDataPattern.jl title= >MLDataPattern.jl</a> gives you tools for building and transforming data containers</p></li><li><p><a href=https://github.com/lorenzoh/DataLoaders.jl title= >DataLoaders.jl</a> takes care of efficient, parallelized iteration of data containers</p></li><li><p><a href=https://github.com/lorenzoh/DLPipelines.jl title= >DLPipelines.jl</a> provides the low-level <code>LearningMethod</code> interface for defining data pipelines.</p></li><li><p><a href=https://github.com/lorenzoh/DataAugmentation.jl title= >DataAugmentation.jl</a> takes care of the lower levels of high-performance, composable data augmentations.</p></li><li><p><a href=https://github.com/lorenzoh/FluxTraining.jl title= >FluxTraining.jl</a> contributes a highly extensible training loop with 2-way callbacks</p></li></ul><p>If that seems like a lot: don’t worry! If you’ve installed FastAI.jl, the functionality of most of these packages is reexported and you don’t have to install any of them explicitly.</p><h3 id=consistency-across-domains >Consistency across domains</h3><p>While computer vision is the only domain with mature support for now, the abstractions underlying FastAI.jl are carefully crafted to ensure that learning tasks for different domains can be created using the same set of interfaces. This shows in that there’s no need for application-specific functionality above the data block API.</p><h2 id=mid-level-apis >Mid-level APIs</h2><h3 id=learner >Learner</h3><p>The <a href=../REFERENCE/FluxTraining.Learner.html ><code>Learner</code></a> is very similar to fastai’s. It takes</p><ul><li><p>a model: any parameterized, differentiable function like a neural network or even <a href=https://fluxml.ai/blog/2019/03/05/dp-vs-rl.html title= >a trebuchet simulator</a></p></li><li><p>training and validation data iterators: these can be <code>DataLoader</code>s which paralellize data loading but any iterator over batches can be used</p></li><li><p>optimizer</p></li><li><p>loss function</p></li></ul><h3 id=two-way-callbacks >Two-way callbacks</h3><p>The training loop also supports two-way callbacks. See the <a href=https://fluxml.ai/FluxTraining.jl/dev/docs/callbacks/reference.md.html title= >FluxTraining.jl docs</a> for a list of all available callbacks. While supporting all the functionality of fastai’s callbacks and training loop, it also provides <a href=https://fluxml.ai/FluxTraining.jl/dev/docs/tutorials/training.md.html title= >an extensible training loop API</a> that makes it straightforward to integrate custom training steps with the available callbacks. As a result, different training steps for problems other than standard supervised training can make use of existing callbacks  without the need to handle control flow through callbacks. Additionally, callbacks have an additional level of safety by being required to declare what state they access and modify. With a little more effort up-front, this guarantees correct ordering of callback execution through <a href=https://fluxml.ai/FluxTraining.jl/dev/docs/callbacks/tipstricks.md.html#visualize-the-callback-dependency-graph title= >a dependency graph</a>. In the future, this will also make it possible to automatically run callbacks in parallel and asynchronously to reduce overhead by long-running callbacks like costly metric calculations and logging over the network.</p><h3 id=encodings-and-blocks >Encodings and blocks</h3><p>In the paper, this subsection is in the low-level section (named Transforms and Pipelines), but I’m putting it here since it is the core of FastAI.jl’s data block API. FastAI.jl provides <code>Encoding</code>s and <code>Block</code>s which correspond to fastai’s <code>Transform</code>s and <code>Block</code>s. Encodings implement an <code>encode</code> (and optionally <code>decode</code>) function that describes how data corresponding to some blocks is transformed and how that transformation can be inverted. There is also support for stateful encodings like <a href=../REFERENCE/FastAI.ProjectiveTransforms.html ><code>ProjectiveTransforms</code></a> which need to use the same random state to augment every data point. Additionally, encodings describe what kind of block data is returned from encoding, allowing inspection of the whole data pipeline. The <code>Block</code>s are used to dispatch in the <code>encode</code> function to implement block-specific transformations. If no <code>encode</code> method is implemented for a pair of encoding and block, the default is to pass the data through unchanged like in fastai.</p><p>The <code>Block</code>s also allow implementing task-specific functionality:</p><ul><li><p><a href=../REFERENCE/FastAI.blocklossfn.html ><code>FastAI.blocklossfn</code></a> takes a prediction and encoded target block to determine a good loss function to use. For example, for image classification we want to compare two one-hot encoded labels and hence define <code>blocklossfn(::OneHotTensor{0}, ::OneHotTensor{0}) = logitcrossentropy</code>.</p></li><li><p><a href=../REFERENCE/FastAI.blockmodel.html ><code>FastAI.blockmodel</code></a> constructs a model from a backbone that maps an input block to an output block. For example, for image segmentation we have <code>ImageTensor{N}()</code> as the input block and <code>OneHotTensor{N}</code> (one-hot encoded N-dimensional masks) as output, so <code>blockmodel</code> turns the backbone into a U-Net.</p></li><li><p><a href=../REFERENCE/FastAI.plotblock!.html ><code>FastAI.plotblock!</code></a> defines how to visualize a block of data. Note that the block plotting API is not stable yet and may change in the future</p></li></ul><h3 id=generic-optimizer >Generic optimizer</h3><p>FastAI.jl uses the optimizers from Flux.jl, which provides a similarly <a href=https://fluxml.ai/Flux.jl/stable/training/optimisers/#Composing-Optimisers title= >composable API for optimzers</a>.</p><h3 id=generalized-metric-api >Generalized metric API</h3><p>Metrics are handled by the <a href=../REFERENCE/FluxTraining.Metrics.html ><code>Metrics</code></a> callback which takes in reducing metric functions or <a href=../REFERENCE/FluxTraining.AbstractMetric.html ><code>FluxTraining.AbstractMetric</code></a>s which have a similar API to fastai’s.</p><h3 id=fastaidataexternal >fastai.data.external</h3><p>FastAI.jl makes all the same datasets available in <code>fastai.data.external</code> available. See <code>FastAI.Datasets.DATASETS</code> for a list of all datasets and use <a href=../REFERENCE/FastAI.Datasets.Datasets.datasetpath.html ><code>datasetpath</code></a><code>(name)</code> to download and extract a dataset.</p><h3 id=funcskwargs-and-dataloader-fastaidatacore >funcs_kwargs and DataLoader, fastai.data.core</h3><p>In FastAI.jl, you are not restricted to a specific type of data iterator and can pass any iterator over batches to <code>Learner</code>. In cases where performance is important <a href=../REFERENCE/DataLoaders.DataLoader.html ><code>DataLoaders.DataLoader</code></a> can speed up data iteration by loading and batching samples in parallel on background threads. All transformations of data happen through the data container interface which requires a type to implement <code>LearnBase.getobs</code> and <code>LearnBase.nobs</code>, similar to PyTorch’s <code>torch.utils.data.Dataset</code>. Data containers are then transformed into other data containers. Some examples:</p><ul><li><p><a href=../REFERENCE/FastAI.Datasets.Datasets.mapobs.html ><code>mapobs</code></a><code>(f, data)</code> lazily maps a function <code>f</code> of over <code>data</code> such that <code>getobs(mapobs(f, data), idx) == f(getobs(data, idx))</code>. For example <code>mapobs(loadfile, files)</code> turns a vector of image files into a data container of images.</p></li><li><p><code>DataLoader(data, batchsize)</code> is a wrapper around <code>batchviewcollated</code> which turns a data container of samples into one of collated batches and <code>eachobsparallel</code> which creates a parallel, buffered iterator over the observations (here batches) in the resulting container.</p></li><li><p><a href=../REFERENCE/FastAI.Datasets.Datasets.groupobs.html ><code>groupobs</code></a><code>(f, data)</code> splits a container into groups using a grouping function <code>f</code>. For example, <code>groupobs(grandparentname, files)</code> creates training splits for files where the grandparent folder indicates the split.</p></li><li><p><a href=../REFERENCE/LearnBase.datasubset.html ><code>LearnBase.datasubset</code></a><code>(data, idxs)</code> lazily takes a subset of the observations in <code>data</code>.</p></li></ul><p>For more information, see the <a href=./data_containers.md.html title= >data container tutorial</a> and the <a href=https://mldatapatternjl.readthedocs.io/en/latest/ title= >MLDataPattern.jl docs</a>. At a higher level, there are also convenience functions like <a href=../REFERENCE/FastAI.Datasets.Datasets.loadfolderdata.html ><code>loadfolderdata</code></a> to create data containers.</p><h3 id=layers-and-architectures >Layers and architectures</h3><p>Flux.jl already does a better job at functionally creating model architectures than PyTorch, so FastAI.jl makes use of its layers. For example <a href=../REFERENCE/Flux.SkipConnection.html ><code>Flux.SkipConnection</code></a>  corresponds to fastai’s <code>MergeLayer</code>. The <code>FastAI.Models</code> submodule currently provides some high-level architectures like <a href=../REFERENCE/FastAI.Models.Models.xresnet18.html ><code>xresnet18</code></a> and a U-Net builder <a href=../REFERENCE/FastAI.Models.Models.UNetDynamic.html ><code>UNetDynamic</code></a> that can create U-Nets from <em>any</em> convolutional feature extractor. The <a href=./setup.md.html title= >optional dependency</a> <a href=https://github.com/FluxML/Metalhead.jl title= >Metalhead.jl</a> also provides common pretrained vision models.</p><h2 id=low-level-apis >Low-level APIs</h2><p>Due to the nature of the Julia language and its design around multiple dispatch, packages tend to compose really well, so it was not necessary to reimplement or provide a unified API for low-level operations. We’ll comment on the libraries that we were able to use.</p><h3 id=pytorch-foundations >PyTorch foundations</h3><p>Unlike Python, Julia has native support for N-dimensional regular arrays. As such, there is a standard interface for arrays and libraries don’t need to implement their own. Consider that every deep learning framework in Python implements their own CPU and GPU arrays, which is part of the reason they are <em>frameworks</em>, not <em>libraries</em> (with the latter being vastly preferable). Julia’s standard libraries implements the standard CPU <code>Array</code> type. GPU arrays are implemented through <a href=https://github.com/JuliaGPU/CUDA.jl title= >CUDA.jl</a> <code>CuArray</code> type (with unified support for GPU vendors other than nvidia in the works). As a result, Flux.jl, the deep learning library of choice for FastAI.jl, does not need to reimplement their own CPU and GPU array versions. This kind of composability in general largely benefits what can be accomplished in Julia.</p><p>Some other libraries which are used under the hood: for image processing, the <a href=https://juliaimages.org/ title= >Images.jl</a> ecosystem of packages is used; for reading and processing tabular data <a href=https://github.com/JuliaData/DataFrames.jl title= >DataFrames.jl</a> and <a href=https://github.com/JuliaData/Tables.jl title= >Tables.jl</a>; for plotting <a href=https://github.com/JuliaPlots/Makie.jl title= >Makie.jl</a>.</p><h3 id=type-dispatch >Type dispatch</h3><p>Multiple dispatch already is a core feature of the Julia language, hence the extensible interfaces in FastAI.jl are built around it and are natural fit for the language.</p><h3 id=object-oriented-semantic-tensors >Object-oriented semantic tensors</h3><p>As mentioned above, Julia has great support for arrays with extra functionality available to packages that provide wrapper arrays like <a href=https://github.com/invenia/NamedDims.jl title= >NamedDims.jl</a> which should generally <em>just work</em> with every part of the library. Hence there is no need for an addtional API that unifies separate packages, which in turn makes FastAI.jl more composable with other packages.</p><p>In encodings, the array types are used for dispatch only where an especially performant implementation is possible, and the block information is used for dispatching the semantics of the encoding.</p><h3 id=gpu-accelerated-augmentation >GPU-accelerated augmentation</h3><p>FastAI.jl does not support GPU-accelerated augmentation (yet). Please open an issue if you run into a situation where data processing <a href=background/datapipelines.md.html title= >becomes the bottleneck</a> and we’ll prioritize this. The affine transformations implemented in DataAugmentation.jl and used in FastAI.jl are properly composed to ensure high quality results. They are also optimized for speed and memory usage (with complete support for inplace transformations).</p><h3 id=convenience-functionality >Convenience functionality</h3><p>Much of the convenience provided by fastai is not required in Julia:</p><ul><li><p><code>@delegates</code>: Due to the absence of deep class hierarchies, keyword arguments are seldom passed around (the only instance where this happens in FastAI.jl is <a href=../REFERENCE/FastAI.methodlearner.html ><code>methodlearner</code></a>).</p></li><li><p><code>@patch</code>: since Julia is built around multiple dispatch, not classes, you just implement the method for a type, no patching needed</p></li><li><p><code>L</code>: due to first-class array support such a wrapper list container isn’t needed</p></li></ul><h2 id=nbdev >nbdev</h2><p>There is no <code>nbdev</code>-equivalent in Julia at the moment. That said, this documentation is generated by a document creation package <a href=https://github.com/lorenzoh/Pollen.jl title= >Pollen.jl</a> that could be extended to support such a workflow. It already has support for different source and output formats like Jupyter notebooks, code execution and is built for interactive work with incremental rebuilds.</p><hr></hr><p>Hopefully this page has given you some context for how FastAI.jl relates to fastai and how to map concepts between the two. You are encouraged to go through the tutorials to see the design decisions made in practice.</p></article><footer class=book-footer ></footer></div><aside class=book-toc ><nav id=toc class=book-toc-content ><ul><li><a href=#fastai-api-comparison >fastai API comparison</a><ul><li><a href=#applications >Applications</a><ul><li><a href=#vision >Vision</a><ul></ul></li><li><a href=#tabular >Tabular</a><ul></ul></li><li><a href=#deployment >Deployment</a><ul></ul></li></ul></li><li><a href=#high-level-api >High-level API</a><ul><li><a href=#high-level-api-foundations >High-level API foundations</a><ul></ul></li><li><a href=#incrementally-adapting-pytorch-code >Incrementally adapting PyTorch code</a><ul></ul></li><li><a href=#consistency-across-domains >Consistency across domains</a><ul></ul></li></ul></li><li><a href=#mid-level-apis >Mid-level APIs</a><ul><li><a href=#learner >Learner</a><ul></ul></li><li><a href=#two-way-callbacks >Two-way callbacks</a><ul></ul></li><li><a href=#encodings-and-blocks >Encodings and blocks</a><ul></ul></li><li><a href=#generic-optimizer >Generic optimizer</a><ul></ul></li><li><a href=#generalized-metric-api >Generalized metric API</a><ul></ul></li><li><a href=#fastaidataexternal >fastai.data.external</a><ul></ul></li><li><a href=#funcskwargs-and-dataloader-fastaidatacore >funcs_kwargs and DataLoader, fastai.data.core</a><ul></ul></li><li><a href=#layers-and-architectures >Layers and architectures</a><ul></ul></li></ul></li><li><a href=#low-level-apis >Low-level APIs</a><ul><li><a href=#pytorch-foundations >PyTorch foundations</a><ul></ul></li><li><a href=#type-dispatch >Type dispatch</a><ul></ul></li><li><a href=#object-oriented-semantic-tensors >Object-oriented semantic tensors</a><ul></ul></li><li><a href=#gpu-accelerated-augmentation >GPU-accelerated augmentation</a><ul></ul></li><li><a href=#convenience-functionality >Convenience functionality</a><ul></ul></li></ul></li><li><a href=#nbdev >nbdev</a><ul></ul></li></ul></li></ul></nav></aside></main></body></HTML>